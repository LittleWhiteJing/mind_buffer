1.假定变量I,f,d数据类型分别为int,float和double(int用补码表示，float和double分别用IEEE754单精度和双精度浮点
数据格式表示)，已知I=785,f=1.5678e^3,d=1.5e^100若在32位机器中执行下列关系表达式，则结果为真是(B)

(I)I==(int)(float)I

(II)f==(float)(int)f    
    
(III)f==(float)(double) f    
    
(IV)(d+f)-d==f

A.仅I和II

B.仅I和III

C.仅II和III

D.仅III和IV

点评：(C/C++)本题考查了C++中数据类型的存储长度相关知识。float和double分别占4个字节和8个字节，float类型转化为int类型

时，由于存储浮点数和整数的方式不同会导致精度丢失。

2.设文件索引节点中有7个地址项，其中4个地址项为直接地址索引，2个地址项是一级间接地址索引，1个地址项是二级间接

地址索引，每个地址项大小为4字节，若磁盘索引块和磁盘数据块大小均为256字节，则可表示的单个文件的最大长度是(C)

A.33kb

B.519kb

C.1057kb

D.16513kb

点评：(编译和体系结构)本题的文件结构属于混合索引分配方式。每个地址项大小为4字节，索引块和盘块大小为256字节，每个索引块

中的项目数 = 256B/4B = 64个。4个地址项为直接地址索引，对应的文件大小为4 × 256 = 1KB。2个地址项是一级间接地址索引，对应

的文件大小是2 × 64 × 256B = 32KB，一个地址项是二级间接地址索引，对应的文件大小为1 × 64 × 64 × 256B = 1024KB，所以单个文件

的最大长度为 = 1KB + 32KB + 1024KB = 1057KB。

3.采用递归方式对顺序表进行快速排序，下列关于递归次数的叙述中，正确的是(D)

A.递归次数与初始数据的排列次序无关

B.每次划分后，先处理较长的分区可以减少递归次数

C.每次划分后，先处理较短的分区可以减少递归次数

D.递归次数与每次划分后得到的分区处理顺序无关

点评：(递归) 递归次数与数据的最开始排列顺序有关，如果有序，递归次数增多，划分后，处理长的分区或处理短的分区可以减少递

归对栈的使用内存，递归次数与先处理长分区或短分区的顺序无关

4.已知一组数据的协方差矩阵P,下面关于主分量说法错误的是(C)

A.主分量分析的最佳准则是对一组数据进行按一组正交基分解, 在只取相同数量分量的条件下,以均方误差计算截尾误差最小

B.在经主分量分解后,协方差矩阵成为对角矩阵

C.主分量分析就是K-L变换

D.主分量是通过求协方差矩阵的特征值得到

点评：(机器学习)K-L变换与PCA变换是不同的概念，PCA的变换矩阵是协方差矩阵，K-L变换的变换矩阵可以有很多种（二阶矩阵、协方差矩阵、

总类内离散度矩阵等等）。当K-L变换矩阵为协方差矩阵时，等同于PCA。

5.对n(n大于等于2)个权值均不相同的字符构成哈夫曼树,关于该树的叙述中,正确的是(A C D)

A.树中一定没有度为1的结点

B.该树一定是一棵完全二叉树

C.树种任一非叶结点的权值一定不小于下一任一结点的权值

D.树中两个权值最小的结点一定是兄弟结点

点评：(树)A 哈夫曼树中，所有的字符串结点都是和其他字符串结点或者权值结点构成子树，因此不可能存在度为1的结点，A正确 

完全二叉树意为前n-1层为满二叉树，最后一层连续缺失右边结点的二叉树，而哈夫曼树无法保证最后一层连续缺失右边结点以及

前n-1层为满二叉树。B错误。哈夫曼树中，父节点的权值是由左右子节点相加得到的，所以任一非叶节点的权值一定不小于下一任

节点的权值。根据生成哈夫曼树的方法可知，树中权值最小的节点一定是兄弟节点。

6.设输入序列是1,3,5....m,经过栈的作用后输出序列的第一个元素是m,则输出序列中第i个输出元素是(A)

A.m-2(i-1)

B.m-i

C.m-1-i

D.m+1-i

7.假定某页面管理系统的内存容量为64KB,分成16块,块号为0,1,2,3,...15.假设某作用4页,其页号为0,1,2,3,被分别装入内存的2,4,1,6块,

其中该作业中第3页在内存中的起始地址(B)

A.2048

B.4096

C.12288

D.8192

点评： 每一块是64KB/16=4KB 0页-2块：起始地址4KB*2=8KB，1页-4块：起始地址4KB*4=16KB，2页-1块：起始地址4KB*1=4KB=4096B

3页-6块：起始地址4KB*6=24KB，总共4页0,1,2,3，那么第三页就是页号为2的页，对应块号1

8. 下面程序输出结果是什么? A

#include<iostream>
using namespace std;
class A{
public:
    A(char *s)
    {
        cout<<s<<endl;
    }
    ~A(){}
};
class B:virtual public A
{
public:
    B(char *s1,char*s2):A(s1){
        cout<<s2<<endl;
    }
};
class C:virtual public A
{
public:
    C(char *s1,char*s2):A(s1){
        cout<<s2<<endl;
    }
};
class D:public B,public C
{
public:
    D(char *s1,char *s2,char *s3,char *s4):B(s1,s2),C(s1,s3),A(s1)
    {
        cout<<s4<<endl;
    }
};
int main() {
    D *p=new D("class A","class B","class C","class D");
    delete p;
    return 0;
}

A.class A class B class C class D

B.class D class B class C class A

C.class D class C class B class A

D.class A class C class B class D

点评：(C++) 和参数顺序没关系的,和继承顺序有关
       
加了virtual后, 继承关系是这样的.	   
	   
     	A
      /   \
     B     C
      \   /
        D

不加的话是这样的

     A     A
     |     |
     B     C
      \   /
        D

9.下面说法错误的是(A B)

A.在组合时,为了保证成员对象被正确清除,在组合类的析构函数中需要显式调用其成员对象的析构函数

B.在类的继承层次中,可以自动进行向上和向下类型转换.而且都是安全的

C.构造函数可以重载,析构函数不能重载

D.C++的派生类如果要覆盖一个继承到的成员函数,在基类中需要将该函数声明为virtual

点评：(C++) A：成员类对象在离开作用域的时候会调用其自身的析构函数，并不需要我们手动delete，

就将其看做一个基本的局部对象即可。除非在构造的时候用了动态类存分配，这又是另外一回事了。

B：明显错误，参考《Effective C++》第39条,不要向下转型。

C：正确，比较简单

D：正确，也是《Effective C++》第37条，如果子类要重写父类方法，需要将父类该方法声明为virtual，实现RTTI。

当然你可以不这样干，结果就是静态绑定。补充一点，重写就叫覆盖。如果没有virtual就是隐藏。 		

10.下面选项中,哪些是interface中合法方法定义?(A C D)

A.public void main(String [] args);

B.private int getSum();

C.boolean setFlag(Boolean [] test);

D.public float get(int x);

点评：(Java)ava程序的入口必须是static类型的，接口中不允许有static类型的方法。A项没有static修饰符，可以作

为普通的方法。而且接口中的方法必须是public的。想想借口就是为了让别人实现的，相当于标准，标准不允许别人使

用是不合理的，所以接口中的方法必须是public。C项中，接口中的方法默认是public的。D项属于正常的方法。

所以答案是：ACD 

11.下面程序的输出是:( D )

String x="fmn";
x.toUpperCase();
String y=x.replace('f','F');
y=y+"wxy";
System.out.println(y);

A.FmNwxy

B.fmnwxy

C.wxyfmn

D.Fmnwxy

12.PHP中,单引号和双引号所包围的字符串有什么区别?( D )

A.单引号解析其中\r\t等转义字符,而双引号不解析

B.双引号速度快,单引号速度慢

C.单引号速度快,双引号速度慢

D.双引号解析其中以$开头的变量,而单引号不解析

13. 查询词提示是现代搜索引擎中广泛使用的一种技术,当用户输入查询词前缀时,会给出一系列相关的查询词推荐,

例如在搜索框内输入"中国",会提示"中国好声音","中国银行", "中国联通"等,尝试设计一个查询词提示系统,回答以下问题:

1.给定一个查询词集合,用何种数据结构和算法来构建最基本的提示系统?要求输入中文和拼音都能正常工作

2.用户输入的前缀下可能有很多可提示的查询词,如何对这些查询词进行排序,将用户选择概率更高的词放在前面? 

点评：美团点评技术团队 http://tech.meituan.com/pinyin-suggest.html









































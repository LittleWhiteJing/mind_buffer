# 线性表部分梳理

## 线性表的定义

若将线性表记为(a1，...，ai-1，ai，ai+1，...，an)，则表中ai-1领先于ai，ai领先于ai+1，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i=1，2,...，n-1时，ai有且仅有一个直接后继，当i=2，3，...，n时，ai有且仅有一个直接前驱。

线性表的元素个数n(n>=0)定义为线性表的长度，当n=0时，称为空表。

线性表的抽象数据类型定义如下

    ADT 线性表(List)

    Data
        线性表的数据对象集合为{a1，a2，...，an}，每个元素的类型为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。

    Operation
        InitList(*L)          初始化操作，建立一个空的线性表L。
        ListEmpty(L)          若线性表为空，返回true，否则返回false。
        ClearList(*L)         将线性表清空。
        GetElem(L,i,*e)       将线性表L中第i个位置元素返回给e
        LocateElem(L,e)       在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功;否则，返回0表示失败。
        ListInsert(*L,i,e)    在线性表L中第i个位置插入新的元素e。
        ListDelete(*L,i,e)    删除线性表L中第i个位置元素，并用e返回其值。
        ListLength(L)         返回线性表L中的元素个数。

    endADT

对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中涉及到的关于线性表的更复杂操作，完全可以用这些基本操作的组合来实现。

## 线性表的存储结构

### 顺序存储

线性表的顺序存储结构指的是用一段地址连续的存储单元依次存储线性表的数据元素。

存储地址计算公式如下

LOC(ai+1) = LOC(ai) + c

LOC(ai) = LOC(a1) + (i-1)*c

#### 存储结构代码

    #define MAXSIZE 20

    typedef int ElemType

    typedef struct {
      ElemType data[MAXSIZE];
      int length;
    }         

#### 获取元素操作

    /*初始条件：顺序线性表L已存在，l<=i<=ListLength(L)*/
    /*操作结果：用e返回L中第i个数据元素的值*/
    Status GetElem(SqList L, int i, ElemType *e) {
      if(L.length==0 || i<1 || i>L.length)
        return ERROR;
      *e = L.data[i-1];
      return OK;  
    }

#### 插入元素操作

#### 删除元素操作

#### 顺序存储的优缺点

顺序存储的线性表，读取，存入数据的时间复杂度为O(1)，插入，删除的时间复杂度是O(n)，它适用于元素个数不太变化，存取操作比较频繁的应用。

**优点**

1.无须为表示元素中元素之间逻辑而增加额外的存储空间。

2.可以快速的存取表中任何位置的元素。

**缺点**

1.插入和删除操作需要移动大量元素。

2.线性表长度变化较大时，难以确定存储空间的容量。

3.造成存储空间的"碎片"。

### 链式存储

线性表的链式存储是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的也可以是不连续的。

除了存储本身信息外，还要存储指向其直接后继的信息。存储元素信息的域称为数据域，存储后继位置的域称为指针域，这两部分信息组成数据元素ai的存储映像，称为节点(Node)

头指针：链表中第一个节点的存储位置叫做头指针。

头节点：链表中第一个节点前附设一个节点称为头节点。

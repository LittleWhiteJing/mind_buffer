# 同步，异步，阻塞，非阻塞概念详解

## 同步与异步

同步和异步的概念与消息通知机制有关，也就是同步与异步主要是从消息通知的角度来讲的。

**同步概念** 一个任务的完成需要依赖另一个任务时，只有等待被依赖的任务完成后，依赖的任务才能完成。要么都成功，要么都失败，两个任务的状态保持一致。这是一种可靠的任务序列。

**异步概念** 一个任务不需要等待被需要的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成整个任务就算完成了。至于被依赖的任务是否真正完成，依赖它的任务无法确定，所以是不可靠的任务序列。

**消息通知** 当一个同步调用发出后，调用者要一直等待返回消息（结果）通知后，才能进行后续的执行；当一个异步调用发出后，调用者不能立刻得到返回消息（结果）。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。

这里提到的执行部件通过三种途径返回结果：状态，通知和回调，使用哪种通信机制依赖于执行部件的实现，不受调用者控制。

1. 如果执行部件用状态来通知，调用者需要每隔一定时间检查一次，效率很低。

2. 如果是使用通知的方式，调用者几乎不需要做额外的操作，效率很高。(回调和通知没太大区别)

## 场景比喻

举个例子，比如我去银行办理业务，可能会有两种方式：

1. 选择排队等候；

2. 另种选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了；

第一种：前者(排队等候)就是同步等待消息通知，也就是我要一直在等待银行办理业务情况；

第二种：后者(等待别人通知)就是异步等待消息通知。在异步消息处理中，等待消息通知者(在这个例子中就是等待办理业务的人)往往注册一个回调机制，在所等待的事件被触发时由触发机制(在这里是柜台的人)通过某种机制(在这里是写在小纸条上的号码，喊号)找到等待该事件的人。

## 阻塞与非阻塞

阻塞与非阻塞这两个概念与程序(线程)等待消息通知时的状态有关，也就是说阻塞与非阻塞主要是程序(线程)等待通知时的状态角度来说的。

**阻塞概念** 是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务。

**非阻塞概念** 指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

**两种方式比较** 非阻塞的方式可以明显的提高CPU的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的CPU执行时间能不能补偿系统的切换成本需要好好评估。

对于一个同步调用来说：

1. 如果这个调用线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫做同步非阻塞。

2. 如果这个调用线程在等待当前函数返回时，没有执行其他消息处理，而是出于挂起状态，那这种情况就叫做同步阻塞。

同理，也存在异步阻塞和异步非阻塞。

**同步非阻塞和异步非阻塞的比较** 同步非阻塞形式上是效率底下的，因为这个程序需要在查看调用结果和执行其他消息这两种不同的行为之间来回切换。而异步非阻塞没有这样的问题，因为调用结果是被调用者通过一定的消息通信机制返回的，而调用者只需处理其他消息。


## 场景比喻

不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中,也就是该程序一直阻塞在该函数调用处不能继续往下执行。

相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他(等待者)没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。

## 四种方式的比较

**同步阻塞形式**

效率是最低的。

拿上面的例子来说，就是你专心排队，什么别的事都不做。

实际程序中：就是未对fd设置O_NONBLOCK标志位的read/write操作；

**异步阻塞形式**

如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发（通知），也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面。

异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。

比如select函数，假如传入的最后一个timeout参数为NULL，那么如果所关注的事件没有一个被触发，程序就会一直阻塞在这个select调用处。

**同步非阻塞形式**

效率是低下的。

想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。

很多人会写阻塞的read/write 操作，但是别忘了可以对fd设置O_NONBLOCK 标志位，这样就可以将同步操作变成非阻塞的了。

**异步非阻塞形式**

在不同的场景下，同步/异步、阻塞/非阻塞的四种组合都有应用。

效率更高。

因为打电话是你(等待者)的事情，而通知你则是柜台(消息触发机制)的事情，程序没有在两种不同的操作中来回切换。

比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下(注册一个回调函数)，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。

如果使用异步非阻塞的情况，比如aio_*组的操作，当发起一个aio_read操作时，函数会马上返回不会被阻塞，当所关注的事件被触发时会调用之前注册的回调函数进行处理。

很多人会把同步和阻塞混淆，我想是因为很多时候同步操作会以阻塞的形式表现出来，比如很多人会写阻塞的read/write操作，但是别忘了可以对fd设置O_NONBLOCK标志位，这样就可以将同步操作变成非阻塞的了。但最根本是因为没有区分这两个概念，比如阻塞的read/write操作中，其实是把消息通知机制和等待消息通知的状态结合在了一起，在这里所关注的消息就是fd是否可读/写，而等待消息通知的状态则是对fd可读/写等待过程中程序（线程）的状态。当我们将这个fd设置为非阻塞的时候，read/write操作就不会在等待消息通知这里阻塞，如果fd不可读/写则操作立即返回。

同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的IO操作处被阻塞，比如如果用select函数，当select返回可读时再去read一般都不会被阻塞，而是在select函数调用处阻塞。

## 场景比喻

以小明下载文件打个比方，从这两个关注点来再次说明这两组概念，希望能够更好的促进大家的理解。

**同步阻塞** 小明一直盯着下载进度条，到 100% 的时候就完成。

> 同步体现在：等待下载完成通知；

> 阻塞体现在：等待下载完成通知过程中，不能做其他任务处理；

**同步非阻塞** 小明提交下载任务后就去干别的，每过一段时间就去瞄一眼进度条，看到 100% 就完成。

>同步体现在：等待下载完成通知；

>非阻塞体现在：等待下载完成通知过程中，去干别的任务了，只是时不时会瞄一眼进度条；【小明必须要在两个任务间切换，关注下载进度】

**异步阻塞** 小明换了个有下载完成通知功能的软件，下载完成就“叮”一声。不过小明仍然一直等待“叮”的声音（看起来很傻，不是吗）。

>异步体现在：下载完成“叮”一声通知；

>阻塞体现在：等待下载完成“叮”一声通知过程中，不能做其他任务处理；

**异步非阻塞** 仍然是那个会“叮”一声的下载软件，小明提交下载任务后就去干别的，听到“叮”的一声就知道完成了。

>异步体现在：下载完成“叮”一声通知；

>非阻塞体现在：等待下载完成“叮”一声通知过程中，去干别的任务了，只需要接收“叮”声通知即可；【软件处理下载任务，小明处理其他任务，不需关注进度，只需接收软件“叮”声通知，即可】


最后，请大家注意理解“消息通知机制”和“等待消息通知时的状态”这两个概念，这是理解四个概念的关键所在。
